export as namespace chevrotain

export declare const VERSION: string

export type ParserMethod<ARGS extends unknown[], R> = (...args: ARGS) => R

/**
 * This class does not actually exist nor is exposed at runtime.
 * This is just a helper to avoid duplications in the Type Definitions
 * Of `CstParser` and `EmbeddedActionsParser`
 */
declare abstract class BaseParser {
  /**
   * This must be called at the end of a Parser constructor.
   * See: http://chevrotain.io/docs/tutorial/step2_parsing.html#under-the-hood
   */
  protected performSelfAnalysis(): void

  /**
   * It is recommended to reuse the same Parser instance
   * by passing an empty array to the input argument
   * and only later setting the input by using the input property.
   * See: http://chevrotain.io/docs/FAQ.html#major-performance-benefits
   *
   * @param tokenVocabulary - A data structure containing all the Tokens used by the Parser.
   * @param config - The Parser's configuration.
   */
  constructor(tokenVocabulary: TokenVocabulary, config?: IParserConfig)

  errors: IRecognitionException[]

  /**
   * Flag indicating the Parser is at the recording phase.
   * Can be used to implement methods similar to {@link BaseParser.ACTION}
   * Or any other logic to requires knowledge of the recording phase.
   * See:
   *   - https://chevrotain.io/docs/guide/internals.html#grammar-recording
   * to learn more on the recording phase and how Chevrotain works.
   */
  RECORDING_PHASE: boolean

  /**
   * Resets the parser state, should be overridden for custom parsers which "carry" additional state.
   * When overriding, remember to also invoke the super implementation!
   */
  reset(): void

  getBaseCstVisitorConstructor<IN = any, OUT = any>(): {
    new (...args: any[]): ICstVisitor<IN, OUT>
  }

  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(): {
    new (...args: any[]): ICstVisitor<IN, OUT>
  }

  getGAstProductions(): Record<string, Rule>

  getSerializedGastProductions(): ISerializedGast[]

  /**
   * @param startRuleName
   * @param precedingInput - The token vector up to (not including) the content assist point
   */
  computeContentAssist(
    startRuleName: string,
    precedingInput: IToken[]
  ): ISyntacticContentAssistPath[]

  /**
   * @param grammarRule - The rule to try and parse in backtracking mode.
   * @param args - argument to be passed to the grammar rule execution
   *
   * @return a lookahead function that will try to parse the given grammarRule and will return true if succeed.
   */
  protected BACKTRACK<T>(
    grammarRule: (...args: any[]) => T,
    args?: any[]
  ): () => boolean

  /**
   * The Semantic Actions wrapper.
   * Should be used to wrap semantic actions that either:
   * - May fail when executing in "recording phase".
   * - Have global side effects that should be avoided during "recording phase".
   *
   * For more information see:
   *   - https://chevrotain.io/docs/guide/internals.html#grammar-recording
   */
  protected ACTION<T>(impl: () => T): T

  /**
   * Like `CONSUME` with the numerical suffix as a parameter, e.g:
   * consume(0, X) === CONSUME(X)
   * consume(1, X) === CONSUME1(X)
   * consume(2, X) === CONSUME2(X)
   * ...
   * @see CONSUME
   */
  protected consume(
    idx: number,
    tokType: TokenType,
    options?: ConsumeMethodOpts
  ): IToken

  /**
   * Like `OPTION` with the numerical suffix as a parameter, e.g:
   * option(0, X) === OPTION(X)
   * option(1, X) === OPTION1(X)
   * option(2, X) === OPTION2(X)
   * ...
   * @see OPTION
   */
  protected option<OUT>(
    idx: number,
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * Like `OR` with the numerical suffix as a parameter, e.g:
   * or(0, X) === OR(X)
   * or(1, X) === OR1(X)
   * or(2, X) === OR2(X)
   * ...
   * @see OR
   */
  protected or(idx: number, altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any
  protected or<T>(idx: number, altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T

  /**
   * Like `MANY` with the numerical suffix as a parameter, e.g:
   * many(0, X) === MANY(X)
   * many(1, X) === MANY1(X)
   * many(2, X) === MANY2(X)
   * ...
   * @see MANY
   */
  protected many(
    idx: number,
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * Like `AT_LEAST_ONE` with the numerical suffix as a parameter, e.g:
   * atLeastOne(0, X) === AT_LEAST_ONE(X)
   * atLeastOne(1, X) === AT_LEAST_ONE1(X)
   * atLeastOne(2, X) === AT_LEAST_ONE2(X)
   * ...
   * @see AT_LEAST_ONE
   */
  protected atLeastOne(
    idx: number,
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   *
   * A Parsing DSL method use to consume a single Token.
   * In EBNF terms this is equivalent to a Terminal.
   *
   * A Token will be consumed, IFF the next token in the token vector matches `tokType`.
   * otherwise the parser may attempt to perform error recovery (if enabled).
   *
   * The index in the method name indicates the unique occurrence of a terminal consumption
   * inside a the top level rule. What this means is that if a terminal appears
   * more than once in a single rule, each appearance must have a **different** index.
   *
   * For example:
   * ```
   *   this.RULE("qualifiedName", () => {
   *   this.CONSUME1(Identifier);
   *     this.MANY(() => {
   *       this.CONSUME1(Dot);
   *       // here we use CONSUME2 because the terminal
   *       // 'Identifier' has already appeared previously in the
   *       // the rule 'parseQualifiedName'
   *       this.CONSUME2(Identifier);
   *     });
   *   })
   * ```
   *
   * - See more details on the [unique suffixes requirement](http://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES).
   *
   * @param tokType - The Type of the token to be consumed.
   * @param options - optional properties to modify the behavior of CONSUME.
   */
  protected CONSUME(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME1(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME2(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME3(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME4(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME5(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME6(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME7(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME8(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * @see CONSUME
   * @hidden
   */
  protected CONSUME9(tokType: TokenType, options?: ConsumeMethodOpts): IToken

  /**
   * Parsing DSL Method that Indicates an Optional production.
   * in EBNF notation this is equivalent to: "[...]".
   *
   * Note that there are two syntax forms:
   * - Passing the grammar action directly:
   *   ```
   *     this.OPTION(() => {
   *       this.CONSUME(Digit)}
   *     );
   *   ```
   *
   * - using an "options" object:
   *   ```
   *     this.OPTION({
   *       GATE:predicateFunc,
   *       DEF: () => {
   *         this.CONSUME(Digit)
   *     }});
   *   ```
   *
   * The optional 'GATE' property in "options" object form can be used to add constraints
   * to invoking the grammar action.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the optional production in it's top rule.
   *
   * @param  actionORMethodDef - The grammar action to optionally invoke once
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   * @returns The `GrammarAction` return value (OUT) if the optional syntax is encountered
   *          or `undefined` if not.
   */
  protected OPTION<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION1<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION2<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION3<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION4<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION5<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION6<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION7<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION8<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * @see OPTION
   * @hidden
   */
  protected OPTION9<OUT>(
    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>
  ): OUT | undefined

  /**
   * Parsing DSL method that indicates a choice between a set of alternatives must be made.
   * This is equivalent to an EBNF alternation (A | B | C | D ...), except
   * that the alternatives are ordered like in a PEG grammar.
   * This means that the **first** matching alternative is always chosen.
   *
   * There are several forms for the inner alternatives array:
   *
   * - Passing alternatives array directly:
   *   ```
   *     this.OR([
   *       { ALT:() => { this.CONSUME(One) }},
   *       { ALT:() => { this.CONSUME(Two) }},
   *       { ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - Passing alternative array directly with predicates (GATE):
   *   ```
   *     this.OR([
   *       { GATE: predicateFunc1, ALT:() => { this.CONSUME(One) }},
   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Two) }},
   *       { GATE: predicateFuncX, ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - These syntax forms can also be mixed:
   *   ```
   *     this.OR([
   *       {
   *         GATE: predicateFunc1,
   *         ALT:() => { this.CONSUME(One) }
   *       },
   *       { ALT:() => { this.CONSUME(Two) }},
   *       { ALT:() => { this.CONSUME(Three) }}
   *     ])
   *   ```
   *
   * - Additionally an "options" object may be used:
   *   ```
   *     this.OR({
   *       DEF:[
   *         { ALT:() => { this.CONSUME(One) }},
   *         { ALT:() => { this.CONSUME(Two) }},
   *         { ALT:() => { this.CONSUME(Three) }}
   *       ],
   *       // OPTIONAL property
   *       ERR_MSG: "A Number"
   *     })
   *   ```
   *
   * The 'predicateFuncX' in the long form can be used to add constraints to choosing the alternative.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the alternation production in it's top rule.
   *
   * @param altsOrOpts - A set of alternatives or an "OPTIONS" object describing the alternatives and optional properties.
   *
   * @returns The result of invoking the chosen alternative.
   */
  protected OR<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR1<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR1(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR2<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR2(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR3<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR3(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR4<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR4(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR5<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR5(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR6<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR6(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR7<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR7(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR8<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR8(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * @see OR
   * @hidden
   */
  protected OR9<T>(altsOrOpts: IOrAlt<T>[] | OrMethodOpts<T>): T
  protected OR9(altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>): any

  /**
   * Parsing DSL method, that indicates a repetition of zero or more.
   * This is equivalent to EBNF repetition \{...\}.
   *
   * Note that there are two syntax forms:
   * - Passing the grammar action directly:
   *   ```
   *     this.MANY(() => {
   *       this.CONSUME(Comma)
   *       this.CONSUME(Digit)
   *      })
   *   ```
   *
   * - using an "options" object:
   *   ```
   *     this.MANY({
   *       GATE: predicateFunc,
   *       DEF: () => {
   *              this.CONSUME(Comma)
   *              this.CONSUME(Digit)
   *            }
   *     });
   *   ```
   *
   * The optional 'GATE' property in "options" object form can be used to add constraints
   * to invoking the grammar action.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the repetition production in it's top rule.
   *
   * @param actionORMethodDef - The grammar action to optionally invoke multiple times
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   */
  protected MANY(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY1(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY2(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY3(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY4(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY5(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY6(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY7(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY8(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * @see MANY
   * @hidden
   */
  protected MANY9(
    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>
  ): void

  /**
   * Parsing DSL method, that indicates a repetition of zero or more with a separator
   * Token between the repetitions.
   *
   * Example:
   *
   * ```
   *     this.MANY_SEP({
   *         SEP:Comma,
   *         DEF: () => {
   *             this.CONSUME(Number};
   *             // ...
   *         })
   * ```
   *
   * Note that because this DSL method always requires more than one argument the options object is always required
   * and it is not possible to use a shorter form like in the MANY DSL method.
   *
   * Note that for the purposes of deciding on whether or not another iteration exists
   * Only a single Token is examined (The separator). Therefore if the grammar being implemented is
   * so "crazy" to require multiple tokens to identify an item separator please use the more basic DSL methods
   * to implement it.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the repetition production in it's top rule.
   *
   * @param options - An object defining the grammar of each iteration and the separator between iterations
   *
   */
  protected MANY_SEP(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP1(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP2(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP3(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP4(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP5(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP6(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP7(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP8(options: ManySepMethodOpts<any>): void

  /**
   * @see MANY_SEP
   * @hidden
   */
  protected MANY_SEP9(options: ManySepMethodOpts<any>): void

  /**
   * Convenience method, same as MANY but the repetition is of one or more.
   * failing to match at least one repetition will result in a parsing error and
   * cause a parsing error.
   *
   * @see MANY
   *
   * @param actionORMethodDef  - The grammar action to optionally invoke multiple times
   *                             or an "OPTIONS" object describing the grammar action and optional properties.
   *
   */
  protected AT_LEAST_ONE(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE1(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE2(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE3(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE4(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE5(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE6(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE7(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE8(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * @see AT_LEAST_ONE
   * @hidden
   */
  protected AT_LEAST_ONE9(
    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>
  ): void

  /**
   * Convenience method, same as MANY_SEP but the repetition is of one or more.
   * failing to match at least one repetition will result in a parsing error and
   * cause the parser to attempt error recovery.
   *
   * Note that an additional optional property ERR_MSG can be used to provide custom error messages.
   *
   * @see MANY_SEP
   *
   * @param options - An object defining the grammar of each iteration and the separator between iterations
   *
   * @return {ISeparatedIterationResult<OUT>}
   */
  protected AT_LEAST_ONE_SEP(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP1(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP2(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP3(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP4(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP5(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP6(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP7(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP8(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * @see AT_LEAST_ONE_SEP
   * @hidden
   */
  protected AT_LEAST_ONE_SEP9(options: AtLeastOneSepMethodOpts<any>): void

  /**
   * Returns an "imaginary" Token to insert when Single Token Insertion is done
   * Override this if you require special behavior in your grammar.
   * For example if an IntegerToken is required provide one with the image '0' so it would be valid syntactically.
   */
  protected getTokenToInsert(tokType: TokenType): IToken

  /**
   * By default, all tokens type may be inserted. This behavior may be overridden in inheriting Recognizers
   * for example: One may decide that only punctuation tokens may be inserted automatically as they have no additional
   * semantic value. (A mandatory semicolon has no additional semantic meaning, but an Integer may have additional meaning
   * depending on its int value and context (Inserting an integer 0 in cardinality: "[1..]" will cause semantic issues
   * as the max of the cardinality will be greater than the min value (and this is a false error!).
   */
  protected canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean

  /**
   * By default, all token types may be deleted. This behavior may be overridden in inheriting parsers.
   * The method receives the expected token type. The token that would be deleted can be received with {@link LA}.
   */
  protected canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean

  /**
   * @deprecated - will be removed in the future
   */
  protected getNextPossibleTokenTypes(
    grammarPath: ITokenGrammarPath
  ): TokenType[]

  input: IToken[]

  /**
   * Will consume a single token and return the **next** token, meaning
   * the token **after** the skipped token.
   */
  protected SKIP_TOKEN(): IToken

  /**
   * Look-Ahead for the Token Vector
   * LA(1) is the next Token ahead.
   * LA(n) is the nth Token ahead.
   * LA(0) is the previously consumed Token.
   *
   * Looking beyond the end of the Token Vector or before its begining
   * will return in an IToken of type EOF {@link EOF}.
   * This behavior can be used to avoid infinite loops.
   *
   * This is often used to implement custom lookahead logic for GATES.
   * https://chevrotain.io/docs/features/gates.html
   */
  protected LA(howMuch: number): IToken
}

/**
 * A Parser that outputs a Concrete Syntax Tree.
 * See:
 *    - https://chevrotain.io/docs/tutorial/step3_adding_actions_root.html#alternatives
 *    - https://chevrotain.io/docs/guide/concrete_syntax_tree.html
 * For in depth docs.
 */
export declare class CstParser extends BaseParser {
  /**
   * Creates a Grammar Rule
   *
   * Note that any parameters of your implementation must be optional as it will
   * be called without parameters during the grammar recording phase.
   */
  protected RULE<F extends () => void>(
    name: string,
    implementation: F,
    config?: IRuleConfig<CstNode>
  ): ParserMethod<Parameters<F>, CstNode>

  /**
   * Overrides a Grammar Rule
   * See usage example in: https://github.com/chevrotain/chevrotain/blob/master/examples/parser/versioning/versioning.js
   */
  protected OVERRIDE_RULE<F extends () => void>(
    name: string,
    implementation: F,
    config?: IRuleConfig<CstNode>
  ): ParserMethod<Parameters<F>, CstNode>

  /**
   * Like `SUBRULE` with the numerical suffix as a parameter, e.g:
   * subrule(0, X) === SUBRULE(X)
   * subrule(1, X) === SUBRULE1(X)
   * subrule(2, X) === SUBRULE2(X)
   * ...
   * @see SUBRULE
   */
  protected subrule<ARGS extends unknown[]>(
    idx: number,
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * The Parsing DSL Method is used by one rule to call another.
   * It is equivalent to a non-Terminal in EBNF notation.
   *
   * This may seem redundant as it does not actually do much.
   * However using it is **mandatory** for all sub rule invocations.
   *
   * Calling another rule without wrapping in SUBRULE(...)
   * will cause errors/mistakes in the Parser's self analysis phase,
   * which will lead to errors in error recovery/automatic lookahead calculation
   * and any other functionality relying on the Parser's self analysis
   * output.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the sub rule invocation in its rule.
   *
   */
  protected SUBRULE<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE1<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE2<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE3<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE4<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE5<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE6<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE7<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE8<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE9<ARGS extends unknown[]>(
    ruleToCall: ParserMethod<ARGS, CstNode>,
    options?: SubruleMethodOpts<ARGS>
  ): CstNode
}

/**
 * A Parser that relies on end user's embedded actions to control its output.
 * For more details see:
 *   - https://chevrotain.io/docs/tutorial/step3_adding_actions_root.html#alternatives
 *   - https://chevrotain.io/docs/tutorial/step3b_adding_actions_embedded.html#simple-example
 */
export declare class EmbeddedActionsParser extends BaseParser {
  /**
   * Creates a Grammar Rule
   *
   * Note that any parameters of your implementation must be optional as it will
   * be called without parameters during the grammar recording phase.
   */
  protected RULE<F extends (...args: any[]) => any>(
    name: string,
    implementation: F,
    config?: IRuleConfig<ReturnType<F>>
  ): ParserMethod<Parameters<F>, ReturnType<F>>

  /**
   * Overrides a Grammar Rule
   * See usage example in: https://github.com/chevrotain/chevrotain/blob/master/examples/parser/versioning/versioning.js
   */
  protected OVERRIDE_RULE<F extends (...args: any[]) => any>(
    name: string,
    implementation: F,
    config?: IRuleConfig<ReturnType<F>>
  ): ParserMethod<Parameters<F>, ReturnType<F>>

  /**
   * Like `SUBRULE` with the numerical suffix as a parameter, e.g:
   * subrule(0, X) === SUBRULE(X)
   * subrule(1, X) === SUBRULE1(X)
   * subrule(2, X) === SUBRULE2(X)
   * ...
   * @see SUBRULE
   */
  protected subrule<ARGS extends unknown[], R>(
    idx: number,
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * The Parsing DSL Method is used by one rule to call another.
   * It is equivalent to a non-Terminal in EBNF notation.
   *
   * This may seem redundant as it does not actually do much.
   * However using it is **mandatory** for all sub rule invocations.
   *
   * Calling another rule without wrapping in SUBRULE(...)
   * will cause errors/mistakes in the Parser's self analysis phase,
   * which will lead to errors in error recovery/automatic lookahead calculation
   * and any other functionality relying on the Parser's self analysis
   * output.
   *
   * As in CONSUME the index in the method name indicates the occurrence
   * of the sub rule invocation in its rule.
   *
   */
  protected SUBRULE<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE1<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE2<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE3<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE4<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE5<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE6<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE7<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE8<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R

  /**
   * @see SUBRULE
   * @hidden
   */
  protected SUBRULE9<ARGS extends unknown[], R>(
    ruleToCall: ParserMethod<ARGS, R>,
    options?: SubruleMethodOpts<ARGS>
  ): R
}

export interface ILexerDefinitionError {
  message: string
  type: LexerDefinitionErrorType
  tokenTypes?: TokenType[]
}

export declare class Lexer {
  static SKIPPED: string

  /**
   * A Constant to mark "abstract" TokenTypes that are used
   * purely as token categories.
   * See: {@link ITokenConfig.categories}
   */
  static NA: RegExp
  lexerDefinitionErrors: ILexerDefinitionError[]

  /**
   * @param lexerDefinition -
   *  Structure composed of Tokens Types this lexer will identify.
   *
   *  In the simple case the structure is an array of TokenTypes.
   *  In the case of {@link IMultiModeLexerDefinition} the structure is an object with two properties:
   *    1. a "modes" property where each value is an array of TokenTypes.
   *    2. a "defaultMode" property specifying the initial lexer mode.
   *
   *  for example:
   *
   *  ```
   *    {
   *        modes : {
   *          modeX : [Token1, Token2],
   *          modeY : [Token3, Token4]
   *        },
   *
   *        defaultMode : "modeY"
   *    }
   *  ```
   *
   *  A lexer with {@link MultiModesDefinition} is simply multiple Lexers where only one Lexer(mode) can be active at the same time.
   *  This is useful for lexing languages where there are different lexing rules depending on context.
   *
   *  The current lexing mode is selected via a "mode stack".
   *  The last (peek) value in the stack will be the current mode of the lexer.
   *  Defining entering and exiting lexer modes is done using the "push_mode" and "pop_mode" properties
   *  of the {@link ITokenConfig} config properties.
   *
   *  - The Lexer will match the **first** pattern that matches, Therefor the order of Token Types is significant.
   *    For example when one pattern may match a prefix of another pattern.
   *
   *    Note that there are situations in which we may wish to order the longer pattern after the shorter one.
   *    For example: [keywords vs Identifiers](https://github.com/chevrotain/chevrotain/tree/master/examples/lexer/keywords_vs_identifiers).
   */
  constructor(
    lexerDefinition: TokenType[] | IMultiModeLexerDefinition,
    config?: ILexerConfig
  )

  /**
   * Will lex(Tokenize) a string.
   * Note that this can be called repeatedly on different strings as this method
   * does not modify the state of the Lexer.
   *
   * @param text - The string to lex
   * @param [initialMode] - The initial Lexer Mode to start with, by default this will be the first mode in the lexer's
   *                                 definition. If the lexer has no explicit modes it will be the implicit single 'default_mode' mode.
   */
  tokenize(text: string, initialMode?: string): ILexingResult
}

export interface ILexingResult {
  tokens: IToken[]
  groups: {
    [groupName: string]: IToken[]
  }
  errors: ILexingError[]
}

export interface ILexingError {
  offset: number
  line: number | undefined
  column: number | undefined
  length: number
  message: string
}

export interface ILexerConfig {
  /**
   * An optional flag indicating that lexer definition errors
   * should not automatically cause an error to be raised.
   * This can be useful when wishing to indicate lexer errors in another manner
   * than simply throwing an error (for example in an online playground).
   */
  deferDefinitionErrorsHandling?: boolean

  /**
   * "full" location information means all six combinations of /(end|start)(Line|Column|Offset)/ properties.
   * "onlyStart" means that only startLine, startColumn and startOffset will be tracked
   * "onlyOffset" means that only the startOffset will be tracked.
   *
   * The less position tracking the faster the Lexer will be and the less memory used.
   * However the difference is not large (~10% On V8), thus reduced location tracking options should only be used
   * in edge cases where every last ounce of performance is needed.
   */
  // TODO: consider renaming this to LocationTracking to align with NodeLocationTracking option on the ParserConfig.
  positionTracking?: "full" | "onlyStart" | "onlyOffset"

  /**
   * A regExp defining custom line terminators.
   * This will be used to calculate the line and column information.
   *
   * Note that the regExp should use the global flag, for example: /\n/g
   *
   * The default is: /\n|\r\n?/g
   *
   * But some grammars have a different definition, for example in ECMAScript:
   * https://www.ecma-international.org/ecma-262/8.0/index.html#sec-line-terminators
   * U+2028 and U+2029 are also treated as line terminators.
   *
   * In that case we would use /\n|\r|\u2028|\u2029/g
   *
   * Note that it is also possible to supply an optimized RegExp like implementation
   * as only a subset of the RegExp APIs is needed, {@link ILineTerminatorsTester}
   * for details.
   *
   * keep in mind that for the default pattern: /\n|\r\n?/g an optimized implementation is already built-in.
   * This means the optimization is only relevant for lexers overriding the default pattern.
   */
  lineTerminatorsPattern?: RegExp | ILineTerminatorsTester

  /**
   * Characters or CharCodes that represent line terminators for this lexer.
   * This always needs to be provided when using a custom {@link ILexerConfig.lineTerminatorsPattern}.
   * In the future this duplication may be removed or reduced.
   */
  lineTerminatorCharacters?: (number | string)[]

  /**
   * When true this flag will cause the Lexer to throw an Error
   * When it is unable to perform all of its performance optimizations.
   *
   * In addition error messages will be printed to the console with details
   * how to resolve the optimizations issues.
   *
   * Use this flag to guarantee higher lexer performance.
   * The optimizations can boost the lexer's performance anywhere from 30%
   * to 100%+ depending on the number of TokenTypes used.
   */
  ensureOptimizations?: boolean

  /**
   * Can be used to disable lexer optimizations
   * If there is a suspicion they are causing incorrect behavior.
   * Note that this would have negative performance implications.
   */
  safeMode?: boolean

  /**
   * A custom error message provider.
   * Can be used to override the default error messages.
   * For example:
   *   - Translating the error messages to a different languages.
   *   - Changing the formatting.
   */
  errorMessageProvider?: ILexerErrorMessageProvider

  /**
   * Enabling this flag will print performance tracing logs during lexer
   * Initialization (constructor invocation), this is useful to narrow down the cause
   * of the initialization performance problem.
   *
   * You can also pass a numerical value which affects the verbosity
   * of the traces, this number is the maximum nesting level of the traces, e.g:
   * 0: Traces disabled === 'false'
   * 1: Top Level traces only.
   * 2: One level of nested inner traces.
   * ...
   *
   * Note that passing the boolean `true` is identical to passing the numerical value `infinity`
   */
  traceInitPerf?: boolean | number

  /**
   * This flag will avoid running the Lexer validations during Lexer initialization.
   *
   * This can substantially improve the Lexer's initialization (constructor) time.
   * @see ILexerConfig.traceInitPerf to measure the Lexer validations cost for your Lexer.
   *
   * Note that the Lexer validations are **extremely useful** during development time,
   * e.g: Detecting empty/invalid regExp Patterns.
   * So they should not be skipped during development flows.
   *   - For example: via a conditional that checks an env variable.
   */
  skipValidations?: boolean

  /**
   * Should the lexer halt on the **first** error, or continue attempting to tokenize by dropping characters
   * until a match is found or the end of input is reached.
   *
   * Setting `recoveryEnabled` to `false` is useful when you want to **halt quickly** on faulty inputs,
   * particularly when dealing with **large** faulty inputs.
   *
   * By default, `recoveryEnabled` is `true`
   */
  recoveryEnabled?: boolean
}

export interface ILexerErrorMessageProvider {
  /**
   * An Unexpected Character Error occurs when the lexer is unable to match a range of one or more
   * characters in the input text against any of the Token Types in it's Lexer definition
   *
   * @param fullText - Full original input text.
   *
   * @param startOffset - Offset in input text where error starts.
   *
   * @param length - Error length.
   *
   * @param line - Line number where the error occurred. (optional)
   *                    Will not be provided when lexer is not defined to track lines/columns
   *
   * @param column - Column number where the error occurred. (optional)
   *                    Will not be provided when lexer is not defined to track lines/columns
   */
  buildUnexpectedCharactersMessage(
    fullText: string,
    startOffset: number,
    length: number,
    line?: number,
    column?: number
  ): string

  /**
   * Unable To Pop Lexer Mode Error happens when lexer tries to pop the last remaining mode from the mode stack
   * so that there is no longer any active lexer mode
   * This error only relevant for multi-mode lexers
   *
   * @param token - The Token that requested pop mode.
   */
  buildUnableToPopLexerModeMessage(token: IToken): string
}

/**
 * This is the default logic Chevrotain uses to construct lexing error messages.
 * It can be used as a reference or as a starting point customize a lexer's
 * error messages.
 *
 * - See: {@link ILexerConfig.errorMessageProvider}
 */
export declare const defaultLexerErrorProvider: ILexerErrorMessageProvider

/**
 * A subset of the regExp interface.
 * Needed to compute line/column info by a chevrotain lexer.
 */
export interface ILineTerminatorsTester {
  /**
   * Just like regExp.test
   */
  test: (text: string) => boolean

  /**
   * Just like the regExp lastIndex with the global flag enabled
   * It